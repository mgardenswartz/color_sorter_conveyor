/**
 * @file PololuEncoder.cpp
 * @brief Driver for a Pololu two-channel gearmotor encoder
 * @author Max Gardenswartz
 * @date Jun 2, 2024
 */

#include "PololuEncoder.h"

PololuEncoder::PololuEncoder(
		TIM_HandleTypeDef* timer_handle,
		uint8_t timer_bit_size,
		UART_HandleTypeDef* uart_handle
		)
		: timer_handle(timer_handle)
{
	HAL_TIM_Encoder_Start(timer_handle, TIM_CHANNEL_ALL);

	// Number of bits for the select timer
	if (timer_bit_size==32)
	{
		max_count = 0xffffffff;
	}
	else
	{
		max_count = 0xffff;
	}

}

void PololuEncoder::update()
{
	// Read encoder
	count = __HAL_TIM_GET_COUNTER(timer_handle);
	delta = (int32_t) (count-last_count);
	last_count = count;

	// Fix delta from timer overflow
	int32_t half_max_count = max_count/2;
	int32_t neg_half_max_count = -half_max_count;
	if (delta > half_max_count)
	{
		// We've overflowed in the negative direction
		delta -= max_count + 1;
	}
	else if (delta < neg_half_max_count)
	{
	    // We've overflowed in the positive direciton.
		delta += max_count + 1;
	}
}

void PololuEncoder::debug_message()
{
	#define VALUE_WIDTH 5
	#define MESSAGE_LENGTH 100
	char my_message[MESSAGE_LENGTH] = "";
    int string_length = snprintf(my_message, MESSAGE_LENGTH, "Encoder cnt: %*i, pos: %*li, delta %*i.\r\n",
                             VALUE_WIDTH, count,
                             VALUE_WIDTH, position,
                             VALUE_WIDTH, delta);
    HAL_UART_Transmit(uart_handle, (uint8_t*)my_message, string_length, HAL_MAX_DELAY);
}

PololuEncoder::~PololuEncoder() {
	// TODO Auto-generated destructor stub
}

