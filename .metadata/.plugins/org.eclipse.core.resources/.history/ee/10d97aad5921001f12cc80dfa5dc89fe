/**
 * @file MotorControl.cpp
 * @brief Takes an encoder and a motor and runs a PID controller
 * @author Max Gardenswartz
 * @date Jun 2, 2024
 */

#include "MotorControl.h"

MotorControl::MotorControl(
						   TB6612FNG_Motor* motor,
						   PololuEncoder* encoder,
						   uint32_t control_frequency_Hz,
						   float K_P,
						   float K_I,
						   float K_D
		)
		: motor(motor),
		  encoder(encoder),
		  control_frequency_Hz(control_frequency_Hz),
		  K_P(K_P),
		  K_I(K_I),
		  K_D(K_D)
{
	reinitialize();
}

MotorControl::~MotorControl()
{
	motor->stop();
}


void MotorControl::run()
{

}


void MotorControl::get_effort_sat(
					float setpoint,
					float process_value
					)
{
	// Error
	error = process_value - setpoint; // RPM, a float
	running_error += error/(float)control_frequency_Hz; // float arithmetic cast to an int

}

void MotorControl::reinitialize()
{
	// Stop motor
	motor->set_duty(0);

	// Reset important stuff
    error = 0;
    effort = 0;
    running_error = 0;

    // Grab the new saturation limit.
    saturation_limit = motor->timer_handle->Instance->ARR; // Assuming no prescalar is used.
}

void MotorControl::update_KP(float new_KP)
{
	reinitialize();
	K_P = new_KP;
}

void MotorControl::update_KI(float new_KI)
{
	reinitialize();
	K_I = new_KI;
}

void MotorControl::update_KD(float new_KD)
{
	reinitialize();
	K_D = new_KD;
}

void MotorControl::update_control_frequency(uint32_t new_control_frequency_Hz)
{
	reinitialize();
	control_frequency_Hz = new_control_frequency_Hz;
}


